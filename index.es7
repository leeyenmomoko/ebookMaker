require("babel-polyfill");
let request = require("request");
let cheerio = require('cheerio');
var Epub = require("epub-gen")
let settings = require('./settings.json');

// http://ck101.com/thread-1321314-1-1.html
let serial = '1321314';
let source = 'ck101';
let title = '聖戒';
let author = '遊魂';
//console.log(settings);

let chkTitle = (str) => {
  let titleRegex = /.*第[1234567890零一二兩三四五六七八九十百佰千萬億兆京垓]*章.*/g;
  if(str.match(titleRegex)){
    return true;
  }
  return false;
};

let getPages = (serial, source) => {
  let promise = new Promise((resolve, reject) => {
    let url = settings[source].link.replace('[serial]', serial).replace('[page]', 1);
    let req = request(url, (error, response, body) => {
      if (!error && response.statusCode == 200) {
        let $ = cheerio.load(body);
        let pages = [];
        $(settings[source].pages_container).each((i, elem) => {
          let pageString = $(elem).text().replace('...', '').trim();
          if( /^\d*$/g.test(pageString)){
            pages.push(pageString);
          }
        });
        resolve(Math.max(...pages));
      }
    });
  });
  return promise;
};

let getContent = (serial, source, page) => {
  let promise = new Promise((resolve, reject) => {
    let url = settings[source].link.replace('[serial]', serial).replace('[page]', page);
    let req = request(url, (error, response, body) => {
      if (!error && response.statusCode == 200) {
        let outputContents = [];
        let $ = cheerio.load(body, {
          normalizeWhitespace: true
        });

        // remove Tags
        for(let tag in settings[source].removeTags){
          if($(tag).length > 0) {
            $(tag).each((i, elem) => {
              switch(settings[source].removeTags[tag]){
                case 'removeTag':
                  $(elem).replaceWith($(elem).text());
                  break;
                case "cleanDuplicate":
                  if(typeof $(elem).next()[0] !== 'undefined' && $(elem).next()[0].name === 'br'){
                    $(elem).remove();
                  }
                  break;
                default:
                  $(elem).replaceWith(settings[source].removeTags[tag]);
              }
            });
          }
        }

        // parse title & content
        $(settings[source].main_content_container).each((i, elem) => {
          let article = {
            title: '',
            content: '',
          };

          let originalContents = $(elem).contents();//.replace('...', '').trim();
          originalContents.each((i, line) => {
            let content = $(line).text().trim().replace(' ', '').replace(' ', '');
            if( content !== ''){
              // check title or content
              if(chkTitle(content) && article.title === ''){
                let last;
                for(let titleSpliter in settings[source].title_spliter){
                  let find = content.indexOf(settings[source].title_spliter[titleSpliter]);
                  if(find !== -1){
                    article.title = content.substr(find+1);
                  }
                }
              }
              else{
                article.content += "<p>" + content + "</p>\n";
              }
            }
          });

          if(article.content.trim() !== ''){
            outputContents.push(article);
          }
        });
        console.log('page ' + page + ' completed.');
        resolve(outputContents);
      }
      else{
        reject(error);
      }
    });

  });

  return promise;
};


let loadSource = async (serial, source, method) => {
  let allContents = [];
  let lastPage = await getPages(serial, source);
  let allPormises = [];
  for(let page = 1; page<=lastPage; page++){
    console.log('start page ' + page);
    let pageContents;
    if( method === 'await'){
      pageContents = await getContent(serial, source, page);
      allContents[page-1] = pageContents;
    }
    else if( method === 'promise'){
      pageContents = getContent(serial, source, page);
      allPormises[page-1] = pageContents;
    }
  }
  if( method === 'await'){
    return allContents;
  }
  else if( method === 'promise'){
    return new Promise((resolve, reject) => {
      Promise.all(allPormises).then((datas) => {
        //allContents = datas;
        resolve(datas);
      });
    });
  }
};

let makeBook = async (serial, source, title, author, method) => {
  let datas = await loadSource(serial, source, method);

  //console.log(datas);
  var option = {
    title: title, // *Required, title of the book.
    author: author, // *Required, name of the author.
    publisher: "Sample Publisher", // optional
    cover: "", // Url or File path, both ok.
    content: []
  };
  // var data = {
  //   lang: 'zh-TW',
  //   title: title,
  //   author: [author],
  //   publisher: 'Sample Publisher',
  //   description: 'none',
  //   contents: [],
  //   identifiers: {},
  //   dates: {
  //     published: new Date().toISOString().split('.')[0]+ 'Z',
  //     modified: new Date().toISOString().split('.')[0]+ 'Z'
  //   },
  //   appendChapterTitles: true,
  //   output: 'output/' + title + '.epub'
  // };
  //console.log(data);
  //data.author.push(author);

  let chapter = 0;
  for(let page in datas){
    for(let articleIndex in datas[page]){
      option.content.push({
        "title": datas[page][articleIndex].title,
        "data": datas[page][articleIndex].content,
        "author": author
      });
    }
  }

  new Epub(option, "output/" + title +".epub");
  console.timeEnd('Some_Name_Here');
};

console.time('Some_Name_Here');

makeBook(serial, source, title, author, 'promise');
